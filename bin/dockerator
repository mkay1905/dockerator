#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Dockerator
"""

# pylint: disable=bad-whitespace

__license__ = """
    Copyright 2015-2017 Waycom <devs@waycom.net>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

import bitmath
import copy
import curses
import glob
import errno
import json
import os
import re
import signal
import socket
import sys
import time
import threading
import yaml

try:
    from docker import APIClient
except ImportError:
    from docker import client as APIClient

from collections import OrderedDict
from docker.errors import APIError, DockerException

import logging
from logging.handlers import WatchedFileHandler
from optparse import OptionParser

from types import ModuleType

DEFAULT_BIND_MODE       = 'rw'
DEFAULT_CONF_FILE       = "/etc/dockerator/dockerator.yml"
DEFAULT_CONFS_DIR       = os.path.join(os.path.dirname(DEFAULT_CONF_FILE), 'conf.d')
DEFAULT_IMG_CONFS_DIR   = os.path.join(os.path.dirname(DEFAULT_CONF_FILE), 'image.d')
DEFAULT_LOG_FILE        = "/var/log/dockerator/dockerator.log"

DEFAULT_RESTART_POLICY  = 'on-failure'
DEFAULT_SCALE_MIN       = 1
DEFAULT_SCALE_MAX       = 1
DEFAULT_SCALE_PORT      = 0
DEFAULT_SCALE_HOST      = '0.0.0.0'

NAME_SCALE_FORMAT       = '%s.%04d.dr'
MATCH_NAME_SCALE        = re.compile(r'^([a-zA-Z0-9][a-zA-Z0-9_\.\-]*)\.([0-9]{4})\.dr$').match
LABEL_NAME_SCALE_FORMAT = '__dockerator.scale.%s.name'
LABEL_BIND_SCALE_FORMAT = '__dockerator.scale.%s.bind'

STATUS_KEYS             = ("Id", "Image", "Command", "Created", "Status", "State", "Ports", "Names")
CURSES_TOP_COLUMNS      = ("Container", "State", "CPU %", "Mem Usage / Limit", "Mem %", "Net I/O", "Block I/O")
CURSES_TOP_LINE_FORMAT  = "{0:50} {1:15} {2:10} {3:25} {4:10} {5:20} {6:20}"

RESTART_POLICIES        = ('always', 'on-failure')

PID_MODES               = ('host',)
NETWORK_MODES           = ('bridge', 'none', 'host')

SYSLOG_NAME             = "Dockerator"
LOG                     = logging.getLogger(SYSLOG_NAME)

_FROM_INIT              = os.getenv('DOCKERATOR_INIT') == 'yes'

ACTION_CHOICES          = ('create',
                           'kill',
                           'list',
                           'monit',
                           'pull',
                           'reload',
                           'remove',
                           'remove-image',
                           'restart',
                           'run',
                           'start',
                           'state',
                           'stats',
                           'status',
                           'stop',
                           'top')

OVERWRITE_ACTIONS       = {'start':   ('run', 'restart', 'reload'),
                           'stop':    ('kill', 'remove',),
                           'reload':  ('restart',),
                           'restart': ('reload',)}

RESOURCE_CHOICES        = ('mem_usage',
                           'mem_limit',
                           'mem_percent',
                           'cpu_percent',
                           'io_read',
                           'io_write',
                           'net_tx',
                           'net_rx')

_CLIENTS                = {}
_IMAGES                 = {'pull':   {},
                           'remove': {}}

StatusContinue          = object()
StatusReturn            = object()

class StatusReturnCode(object):
    RETURN_CODE = 0


def argv_parse_check():
    """
    Parse (and check a little) command line parameters
    """
    parser              = OptionParser(usage="usage: %prog [options] [action]")

    parser.add_option("-a",
                      dest      = 'action',
                      default   = 'list',
                      choices   = ACTION_CHOICES,
                      help      = ("Choice action on one or many containers:\n" + \
                                   ", ".join(ACTION_CHOICES)))
    parser.add_option("-c",
                      dest      = 'conffile',
                      type      = 'string',
                      default   = DEFAULT_CONF_FILE,
                      help      = "Use configuration file <conffile> instead of %default")
    parser.add_option("--configs-dir",
                      dest      = 'confsdir',
                      type      = 'string',
                      default   = DEFAULT_CONFS_DIR,
                      help      = "Use configuration directory <confsdir> instead of %default")
    parser.add_option('--docker-url',
                      dest      = 'dockerurl',
                      type      = 'string',
                      help      = "Use a specific Docker server")
    parser.add_option("-f",
                      action    = 'store_true',
                      dest      = 'force',
                      default   = False,
                      help      = "Force")
    parser.add_option("--image-name",
                      dest      = 'imgname',
                      type      = 'string',
                      help      = "Choice container by image")
    parser.add_option("--image-configs-dir",
                      dest      = 'imgconfsdir',
                      type      = 'string',
                      default   = DEFAULT_IMG_CONFS_DIR,
                      help      = "Use configuration directory <imgconfsdir> for images instead of %default")
    parser.add_option("-n",
                      dest      = 'name',
                      type      = 'string',
                      help      = "Choice container by name")
    parser.add_option("--logfile",
                      dest      = 'logfile',
                      type      = 'string',
                      default   = DEFAULT_LOG_FILE,
                      help      = "Use log file <logfile> instead of %default")
    parser.add_option("-l",
                      dest      = 'loglevel',
                      default   = 'info',   # warning: see affectation under
                      choices   = ('critical', 'error', 'warning', 'info', 'debug'),
                      help      = ("Emit traces with LOGLEVEL details, must be one of:\t"
                                   "critical, error, warning, info, debug"))
    parser.add_option("--rsc",
                      action    = 'append',
                      dest      = 'resource',
                      default   = [],
                      choices   = RESOURCE_CHOICES,
                      help      = "Resource information:\n" + \
                                  ", ".join(RESOURCE_CHOICES) + " (only available with actions monit or stats)")
    parser.add_option("--scale",
                      dest      = 'scale',
                      default   = False,
                      help      = "Scaling container (value must be auto or container name, e.g.: auto:1 or foo:2)")

    options, args       = parser.parse_args()

    if args and args[0] in ACTION_CHOICES:
        options.action  = args.pop(0)

    if args:
        parser.error("only argument [action] is allowed - use option --help to get an help screen")

    if not options.resource:
        options.resource = RESOURCE_CHOICES

    if options.action == 'monit':
        options.resource = [options.resource[0]]
    else:
        options.resource = list(set(options.resource))

    options.loglevel    = getattr(logging, options.loglevel.upper(), logging.INFO)

    return options


class DockeratorConfigException(Exception):
    pass


class Dockerator(object):
    def __init__(self, options, default_conf):
        self.options      = options
        self.default_conf = default_conf
        self.action       = options.action
        self.cli          = None
        self.scale        = None
        self.scale_nb     = 0
        self._killed      = False

        signal.signal(signal.SIGTERM, self._kill)
        signal.signal(signal.SIGINT, self._kill)

        if options.scale:
            self.scale, scale_nb, unused = ("%s:1:" % options.scale).split(':', 2)
            if scale_nb.isdigit():
                self.scale_nb = int(scale_nb)
            else:
                self.scale_nb = 1

        self.confs        = self._build_conf()

    def _kill(self, signum = None, stack_frame = None):
        self._killed = True

    def is_killed(self):
        return self._killed

    def set_client(self, cli):
        self.cli = cli
        return self

    def remove_if_stale_cidfile(self, cidfile):
        """
        @cidfile: CID file to remove if it is staled.

        Exceptions are logged and are not propagated.
        """
        try:
            try:
                with open(cidfile, 'r') as f:
                    cid_instance = f.readline().strip()
            except IOError, e:
                if e.errno == errno.ENOENT:
                    return # nothing to suppress, so do nothing...
                raise

            for container in self.cli.containers(**{'all':     True,
                                                    'trunc':   False,
                                                    'quiet':   True}):
                if container['Id'] == cid_instance:
                    LOG.warning("A cidfile %r already exists (contains cid %r) and an container is running with that cid.",
                                cidfile,
                                cid_instance)
                    return
            os.unlink(cidfile)
            return
        except Exception: # pylint: disable=W0703
            LOG.exception("unexpected error")

    @staticmethod
    def take_file_lock(own_file, lock_file, own_content):
        """
        Atomically "move" @own_file to @lock_file if the latter does not exist,
        else just remove @own_file.

        @own_file: filepath of the temporary file that contains our PID
        @lock_file: destination filepath
        @own_content: content of @own_file

        Returns True if the lock has been successfully taken, else False.
        (Caller should also be prepared for OSError exceptions)
        """
        try:
            try:
                os.link(own_file, lock_file)
            finally:
                os.unlink(own_file)
        except OSError, e:
            if e.errno == errno.EEXIST:
                LOG.warning("The lock file %r already exists - won't "
                            "overwrite it.  An other instance of ourself "
                            "is probably running.", lock_file)
                return False
            else:
                raise

        with open(lock_file, 'r') as f:
            content = f.read(len(own_content) + 1)

        if content != own_content:
            LOG.warning("I thought I successfully took the lock file %r but "
                        "it does not contain what was expected.  Somebody is "
                        "playing with us.", lock_file)
            return False

        return True

    def lock_cidfile(self, cid, cidfile):
        """
        @cid:
            current cid
        @cidfile:
            must be a writable path

        Exceptions are logged.

        Returns the CID.
        """
        try:
            self.remove_if_stale_cidfile(cidfile)
            cid_write_file = "%s.%s" % (cidfile, cid)
            fcid           = None
            try:
                with open(cid_write_file, 'w') as fcid:
                    fcid.write("%s\n" % cid)
            finally:
                if fcid:
                    fcid.close()
            if not self.take_file_lock(cid_write_file, cidfile, "%s\n" % cid):
                return False
        except SystemExit:
            raise
        except Exception:
            LOG.exception("unable to take cidfile")
            return False

        return cid

    def unlock_cidfile(self, cidfile):
        """
        @cidfile:
            must be a writable path

        Exceptions are logged.

        Returns the CID.
        """
        try:
            self.remove_if_stale_cidfile(cidfile)
        except SystemExit:
            raise
        except Exception:
            LOG.exception("unable to take cidfile")
            return False

        return True

    @staticmethod
    def _get_action(action, conf):
        if action not in OVERWRITE_ACTIONS:
            return action

        action_name = "action_%s" % action

        if conf.get(action_name) not in OVERWRITE_ACTIONS[action]:
            return action

        return conf[action_name]

    @classmethod
    def _conf_params(cls, current, params):
        r   = {}

        if not isinstance(current, dict):
            return r

        for key, value in current.iteritems():
            if isinstance(key, basestring):
                k    = key % params
            else:
                k    = key

            if isinstance(value, basestring):
                r[k] = value % params
            elif isinstance(value, dict):
                r[k] = cls._conf_params(value, params)
            else:
                r[k] = value

        return r

    @staticmethod
    def _find_scale_port(host, port):
        sock = socket.socket()

        while True:
            if port >= 65500:
                raise DockeratorConfigException("Unable to find an available port")

            try:
                sock.bind((host, port))
            except Exception, e:
                LOG.debug("Port %r:%r unavailable. ( %r)", host, port, e)
                port += 1
            else:
                port = sock.getsockname()[1]
                sock.close()
                time.sleep(0.1)
                return port

    @classmethod
    def _conf_merge(cls, current, default):
        if isinstance(current, dict) and isinstance(default, dict):
            xcur = current.copy()
            xdef = default.copy()

            for key, value in xdef.iteritems():
                if key not in xcur:
                    current[key] = value
                else:
                    current[key] = cls._conf_merge(xcur[key], value)

        return current

    @staticmethod
    def _set_container_scale_default(sname, num, host, conf):
        return {'exists': False,
                'state': None,
                'name': sname,
                'number': num,
                'host': host,
                'conf': copy.deepcopy(conf)}

    def _set_container_scale_bind(self, name, sname, ref, label_name, info = None, bind = None):
        label_bind = LABEL_BIND_SCALE_FORMAT % name

        if bind:
            ref['bind'] = bind
        elif info:
            ref['state']  = info['State']
            if 'Labels' in info and label_bind in info['Labels']:
                ref['bind'] = info['Labels'][label_bind]
        else:
            raise DockeratorConfigException("missing scaling bind configuration (name: %r)" % sname)

        ref['host'], ref['port']            = ref['bind'].split(':', 1)
        ref['conf']['general']['host_ip']   = ref['host']
        ref['conf']['general']['host_port'] = ref['port']

        if 'labels' not in ref['conf']['general']:
            ref['conf']['general']['labels'] = {}

        ref['conf']['general']['labels'][label_name] = name
        ref['conf']['general']['labels'][label_bind] = ref['bind']

        ref['conf'] = self._build_conf_end(sname, ref['conf'])

    @staticmethod
    def _get_min_max_scale(r, conf):
        for x in ('min', 'max'):
            if x not in conf:
                continue

            try:
                r[x] = int(conf[x])
            except ValueError, e:
                raise DockeratorConfigException("Invalid configuration option %r in 'scale' (error: %r)" % (x, e))

        if r['min'] < 2:
            r['min'] = 1

        if r['min'] > r['max']:
            raise DockeratorConfigException("Invalid 'min' or 'max' value in 'scale' (min: %r, max: %r)"
                                            % (r['min'],
                                               r['max']))

        return r

    @staticmethod
    def _get_host_port_scale(conf):
        port = None

        if 'port' in conf:
            try:
                port = int(conf['port'])
            except ValueError, e:
                raise DockeratorConfigException("Invalid configuration option 'port' in 'scale' (error: %r)" % e)

            if not 1024 < port < 65500:
                raise DockeratorConfigException("Invalid 'port' value in 'scale' (port: %r)" % port)

        if port is None:
            port = DEFAULT_SCALE_PORT

        return (conf.get('host', DEFAULT_SCALE_HOST), port)

    def _build_conf_scale(self, name, docker_url, conf):
        label_name = LABEL_NAME_SCALE_FORMAT % name

        r = {'min':        DEFAULT_SCALE_MIN,
             'max':        DEFAULT_SCALE_MAX,
             'count':      0,
             'containers': {}}

        self._get_min_max_scale(r, conf['scale'])
        host, port = self._get_host_port_scale(conf['scale'])

        self.set_client(self.register_client(docker_url))
        containers = self.cli.containers(**{'all': True, 'filters': {'label': label_name}})
        r['count'] = len(containers)

        if r['count']:
            for info in containers:
                num     = None
                sname   = None
                if 'Names' not in info:
                    continue

                for sname in info['Names']:
                    sname = sname[1:]
                    m = MATCH_NAME_SCALE(sname)
                    if m:
                        num = int(m.group(2))
                        break

                if num is None:
                    continue

                r['containers'][sname] = self._set_container_scale_default(sname, num, host, conf)
                ref = r['containers'][sname]

                ref['exists'] = True
                self._set_container_scale_bind(name, sname, ref, label_name, info)

        for num in range(r['min'] - 1, r['max']):
            sname = NAME_SCALE_FORMAT % (name, num)
            r['containers'][sname] = self._set_container_scale_default(sname, num, host, conf)
            ref = r['containers'][sname]

            for info in self.cli.containers(**{'all': True, 'filters': {'name': sname}}):
                if 'Names' not in info or "/%s" % sname not in info['Names']:
                    continue

                ref['exists'] = True
                self._set_container_scale_bind(name, sname, ref, label_name, info)

            if self.action not in ('create', 'reload', 'restart', 'run', 'start'):
                ref['conf'] = self._build_conf_end(sname, ref['conf'])
                continue

            if not port:
                sport = port
            else:
                sport = port + num

            sport = self._find_scale_port(ref['host'], sport)

            if not sport:
                ref['conf'] = self._build_conf_end(sname, ref['conf'])
                LOG.warning("Unable to find an available port for %r", port)
                break

            if port:
                port += 1

            ref['port'] = sport
            ref['conf']['general']['name'] = sname

            self._set_container_scale_bind(
                name,
                sname,
                ref,
                label_name,
                None,
                "%s:%s" % (ref['host'], ref['port']))

        conf['scale'] = r

    def _build_conf_merged(self, current_conf, default_conf):
        r = self._conf_merge(current_conf, default_conf)

        if r['general'].get('image_cfg_file'):
            if not os.access(r['general']['image_cfg_file'], os.F_OK):
                xfile = os.path.join(self.options.imgconfsdir, r['general']['image_cfg_file'])
            else:
                xfile = r['general']['image_cfg_file']

            with open(xfile, 'r') as f:
                r = self._conf_merge(r, yaml.load(f))

        if self.options.dockerurl:
            r['docker_url'] = self.options.dockerurl
        else:
            r['docker_url'] = r['general']['docker_url']

        return r

    def _build_conf_end(self, name, conf):
        r = self._conf_params(conf,
                              {'DOCKER_NAME':    name,
                               'hostname':       socket.gethostname(),
                               'container_port': conf['general'].get('container_port', ''),
                               'host_ip':        conf['general'].get('host_ip', ''),
                               'host_port':      conf['general'].get('host_port', '')})

        r['_stats'] = {}

        if _FROM_INIT == 'yes':
            r['action'] = self._get_action(self.options.action, conf['init'])
            r['enable'] = bool(conf['init'].get('container_enable', False))
        else:
            r['action'] = self._get_action(self.options.action, conf['general'])
            r['enable'] = bool(conf['general'].get('container_enable', True))

        return r

    def _build_conf(self):
        if not os.path.isdir(self.options.confsdir) \
           or not os.access(self.options.confsdir, os.R_OK):
            LOG.warning("Configurations directory doesn't exist "
                        "or isn't readable. (confsdir: %r)",
                        self.options.confsdir)
            return

        r = {'names':  {},
             'images': {}}

        for x in os.listdir(self.options.confsdir):
            conf_file = os.path.join(self.options.confsdir, x)
            if not (os.path.isfile(conf_file) \
               and os.access(conf_file, os.R_OK) \
               and not conf_file.startswith('.') \
               and conf_file.endswith('.yml')):
                continue

            default_conf = copy.deepcopy(self.default_conf)

            with open(conf_file, 'r') as f:
                current_conf = yaml.load(f)

            if not isinstance(current_conf, dict):
                raise DockeratorConfigException("Invalid configuration file: %r" % conf_file)
            if 'general' not in current_conf:
                raise DockeratorConfigException("Missing configuration section 'general' in file: %r" % conf_file)
            if not isinstance(current_conf['general'], dict):
                raise DockeratorConfigException("Invalid configuration for section 'general' in file: %r" % conf_file)
            if 'name' not in current_conf['general']:
                raise DockeratorConfigException("Missing configuration option 'name' for section 'general' in file: %r" % conf_file)

            conf_merged = self._build_conf_merged(current_conf, default_conf)

            docker_name = conf_merged['general']['name']
            image_name  = conf_merged['general']['image']

            conf_merged['general']['realname'] = docker_name

            if self.scale and (not self.options.name or self.options.name == docker_name):
                if 'scale' not in conf_merged or not isinstance(conf_merged['scale'], dict):
                    raise DockeratorConfigException("Missing configuration section 'scale' in file: %r" % conf_file)
                self._build_conf_scale(docker_name, conf_merged['docker_url'], conf_merged)

            r['names'][docker_name] = self._build_conf_end(docker_name, conf_merged)

            if image_name not in r['images']:
                r['images'][image_name] = {}

            r['images'][image_name][docker_name] = r['names'][docker_name]

            if 'cid_file' not in current_conf['general']:
                raise DockeratorConfigException("Missing configuration option 'cid_file' "
                                                "for section 'general' in file: %r" % conf_file)

        return r

    @staticmethod
    def register_client(docker_url):
        if docker_url in _CLIENTS:
            return _CLIENTS[docker_url]

        if isinstance(APIClient, ModuleType):
            try:
                _CLIENTS[docker_url] = APIClient.AutoVersionClient(docker_url)
            except AttributeError:
                _CLIENTS[docker_url] = APIClient.Client(docker_url)
        else:
            _CLIENTS[docker_url] = APIClient(docker_url)

        return _CLIENTS[docker_url]

    def get_scale_conf(self, name, conf):
        r       = OrderedDict()

        exists  = False
        reverse = False
        recheck = False
        state   = False
        states  = (None,)

        if self.action in ('kill', 'stop'):
            exists  = True
            reverse = True
            recheck = self.scale == 'auto'
            states  = ('running', 'paused',)
        elif self.action in ('remove',):
            exists  = True
            reverse = True
            recheck = self.scale == 'auto'
            states  = ('exited', 'dead', 'paused',)
        elif self.action in ('reload', 'restart'):
            exists  = True
            reverse = False
            recheck = self.scale == 'auto'
            states  = ('exited', 'dead', 'paused',)
        elif self.action in ('monit', 'state', 'stats', 'status', 'top'):
            exists  = True
            state   = True

        xdict = copy.deepcopy(conf['containers'])
        xsort = sorted(xdict.iterkeys(), reverse = reverse)
        nb    = 0

        if recheck:
            for xstate in states:
                for container in xsort:
                    if not container in xdict:
                        continue
                    ref = xdict[container]
                    if ref['exists'] == exists and ref['state'] == xstate:
                        r[ref['name']] = ref['conf']
                        del xdict[container]
                        nb += 1
                        if nb == self.scale_nb and not state:
                            return r

        for container in xsort:
            if not container in xdict:
                continue
            ref = xdict[container]
            if self.scale in (container, 'auto') and ref['exists'] == exists:
                r[ref['name']] = ref['conf']
                del xdict[container]
                nb += 1
                if nb == self.scale_nb and not state:
                    return r

        if self.options.force and self.action in ('kill', 'reload', 'run'):
            for container in xsort:
                if not container in xdict:
                    continue
                ref = xdict[container]
                if self.scale in (container, 'auto'):
                    r[ref['name']] = ref['conf']
                    del xdict[container]
                    nb += 1
                    if nb == self.scale_nb and not state:
                        return r

        if r:
            return r

        if self.scale == 'auto':
            flog = LOG.warning
        else:
            flog = LOG.debug

        flog("No scaling container available for %r", name)

    def get_current_conf(self):
        if self.options.name:
            if self.options.name not in self.confs['names']:
                LOG.error("Container %r doesn't exist", self.options.name)
                return
            if not self.scale:
                return {self.options.name: self.confs['names'][self.options.name]}

            return self.get_scale_conf(self.options.name,
                                       self.confs['names'][self.options.name]['scale'])
        elif self.options.imgname:
            if self.options.imgname not in self.confs['images']:
                LOG.error("Image %r not found in configuration files", self.options.imgname)
            elif not self.scale:
                return self.confs['images'][self.options.imgname]
            else:
                conf = {}
                for name, container in self.confs['names'].iteritems():
                    scale_conf = self.get_scale_conf(name, container['scale'])
                    if scale_conf:
                        conf.update(scale_conf)
                return conf
        else:
            if not self.scale:
                return self.confs['names']

            conf = {}
            for name, container in self.confs['names'].iteritems():
                scale_conf = self.get_scale_conf(name, container['scale'])
                if scale_conf:
                    conf.update(scale_conf)

            return conf

    @staticmethod
    def _build_param_hc_restart_policy(container_restart):
        if isinstance(container_restart, basestring):
            if container_restart in RESTART_POLICIES:
                return {'MaximumRetryCount': 0,
                        'name':              container_restart}
            else:
                raise DockeratorConfigException("Invalid configuration option 'container_restart' in 'general'")
        elif isinstance(container_restart, dict):
            r = {}

            if 'max_retry' in container_restart:
                r['MaximumRetryCount'] = int(container_restart['max_retry'])

            if 'name' in container_restart:
                if container_restart['name'] in RESTART_POLICIES:
                    r['Name'] = container_restart['name']
                else:
                    r['Name'] = DEFAULT_RESTART_POLICY

            return r

    @staticmethod
    def _build_param_hc_network_mode(network_mode):
        if not isinstance(network_mode, basestring):
            raise DockeratorConfigException("Invalid type for option 'network_mode' in 'general'")
        elif network_mode in NETWORK_MODES:
            return network_mode
        elif network_mode.startswith('container:'):
            return network_mode
        else:
            raise DockeratorConfigException("Invalid configuration option 'network_mode' in 'general'")

    @staticmethod
    def _build_param_hc_pid_mode(pid_mode):
        if not isinstance(pid_mode, basestring):
            raise DockeratorConfigException("Invalid type for option 'pid_mode' in 'general'")
        elif pid_mode in PID_MODES:
            return pid_mode
        elif pid_mode.startswith('container:'):
            return pid_mode
        else:
            raise DockeratorConfigException("Invalid configuration option 'pid_mode' in 'general'")

    @staticmethod
    def _build_param_hc_host(hosts):
        r = {}

        for key, value in hosts.iteritems():
            if isinstance(key, basestring) \
               and isinstance(value, basestring):
                r[key] = value

        return r

    @staticmethod
    def _build_param_hc_port(conf):
        ports   = set()

        if 'ports' in conf and isinstance(conf['ports'], dict):
            for key, value in conf['ports'].iteritems():
                publish = ("%s:%s" % (value or '', key)).strip(':')
                if publish:
                    ports.add(publish)

        if not ports:
            publish = ("%s:%s:%s" % (conf['general'].get('host_ip') or '',
                                     conf['general'].get('host_port') or '',
                                     conf['general'].get('container_port') or '')).strip(':')
            if publish:
                ports.add(publish)

        if not ports:
            return

        r = {}

        for port in ports:
            binding        = port.rsplit(':', 2)
            container_port = binding.pop(-1)
            if binding:
                r[container_port] = tuple(binding)
            else:
                r[container_port] = []

        return r

    @staticmethod
    def _build_param_hc_volumes(volumes, ivolume = False):
        r = []

        for key, value in volumes.iteritems():
            if isinstance(value, basestring):
                if ivolume and not os.path.exists(key):
                    continue
                r.append("%s:%s:%s" % (key, value, DEFAULT_BIND_MODE))

            if not isinstance(value, dict):
                continue

            if not value.get('destination'):
                LOG.warning("Missing destination for volume: %r", key)
                continue

            mode = value.get('mode') or DEFAULT_BIND_MODE

            if not isinstance(value['destination'], list):
                destination = [value['destination']]
            else:
                destination = list(value['destination'])

            for dest in destination:
                if not value.get('glob'):
                    if ivolume and not os.path.exists(key):
                        continue
                    r.append("%s:%s:%s" % (key, dest, mode))
                else:
                    for x in glob.glob(key):
                        r.append("%s:%s:%s" % (x, os.path.join(dest, os.path.basename(x)), mode))

        return r

    @staticmethod
    def _build_param_links(links):
        if isinstance(links, dict):
            return links.copy()

        raise DockeratorConfigException("Invalid configuration option 'links' in 'general'")

    @staticmethod
    def _build_param_labels(labels):
        if isinstance(labels, dict):
            return labels.copy()

        raise DockeratorConfigException("Invalid configuration option 'labels' in 'general'")

    @staticmethod
    def _build_param_command(docker_cmds):
        r = []

        if isinstance(docker_cmds, basestring):
            r.append(docker_cmds)
        elif isinstance(docker_cmds, list):
            r.extend(docker_cmds)
        else:
            raise DockeratorConfigException("Invalid configuration option 'docker_cmds' in 'general'")

        return r

    @staticmethod
    def _build_param_hc_volumes_from(names):
        r = []

        if isinstance(names, basestring):
            r.append(names)
        elif isinstance(names, list):
            r.extend(names)
        else:
            raise DockeratorConfigException("Invalid configuration option 'volumes_from' in 'general'")

        return r

    @staticmethod
    def _build_param_host_config(conf):
        host_config = {}

        if 'container_restart' in conf['general']:
            container_restart = Dockerator._build_param_hc_restart_policy(conf['general']['container_restart'])
            if container_restart:
                host_config['restart_policy'] = container_restart

        if 'links' in conf['general']:
            links = Dockerator._build_param_links(conf['general']['links'])
            if links:
                host_config['links'] = links

        for x in ('mem_limit', 'memswap_limit', 'shm_size'):
            if x not in conf['general']:
                continue
            elif not isinstance(conf['general'][x], (int, str)):
                raise DockeratorConfigException("Invalid configuration option %r in 'general'" % x)
            else:
                host_config[x] = conf['general'][x]

        for x in ('publish_all_ports', 'privileged'):
            if x in conf['general']:
                host_config[x] = bool(conf['general'][x])

        for x in ('cpu_group', 'cpu_period'):
            if x in conf['general']:
                host_config[x] = int(conf['general'][x])

        if 'network_mode' in conf['general']:
            host_config['network_mode'] = Dockerator._build_param_hc_network_mode(conf['general']['network_mode'])

        if 'pid_mode' in conf['general']:
            host_config['pid_mode'] = Dockerator._build_param_hc_pid_mode(conf['general']['pid_mode'])

        if 'volumes_from' in conf['general']:
            host_config['volumes_from'] = Dockerator._build_param_hc_volumes_from(conf['general']['volumes_from'])

        if 'ports' in conf and isinstance(conf['ports'], dict):
            ports = Dockerator._build_param_hc_port(conf)
            if ports:
                host_config['port_bindings'] = ports

        if 'hosts' in conf and isinstance(conf['hosts'], dict):
            extra_hosts = Dockerator._build_param_hc_host(conf['hosts'])
            if extra_hosts:
                host_config['extra_hosts'] = extra_hosts

        host_config['binds'] = []

        if 'volumes' in conf and isinstance(conf['volumes'], dict):
            host_config['binds'].extend(Dockerator._build_param_hc_volumes(conf['volumes'], False))

        if 'ivolumes' in conf and isinstance(conf['ivolumes'], dict):
            host_config['binds'].extend(Dockerator._build_param_hc_volumes(conf['ivolumes'], True))

        if not host_config['binds']:
            del host_config['binds']

        return host_config

    @staticmethod
    def _build_create_params(conf):
        params      = {'name':        conf['general']['name'],
                       'image':       conf['general']['image'],
                       'detach':      True,
                       'environment': {}}

        host_config = Dockerator._build_param_host_config(conf)
        if host_config:
            params['host_config'] = host_config

        if 'cpu_shares' in conf['general']:
            params['cpu_shares'] = int(conf['general']['cpu_shares'])

        params['environment']['DOCKER_NAME'] = conf['general']['name']

        if 'environment' in conf and isinstance(conf['environment'], dict):
            for key, value in conf['environment'].iteritems():
                params['environment'][key] = "%s" % value

        if 'labels' in conf['general']:
            labels = Dockerator._build_param_labels(conf['general']['labels'])
            if labels:
                params['labels'] = labels

        if 'network_disabled' in conf['general']:
            params['network_disabled'] = bool(conf['general']['network_disabled'])

        if conf['general'].get('docker_cmds'):
            command = Dockerator._build_param_command(conf['general']['docker_cmds'])
            if command:
                params['command'] = command

        return params

    def _get_state(self, xid):
        res = self.cli.inspect_container(xid)
        if not res:
            return

        return res['State']['Status']

    def _find_container(self, name, conf):
        containers = self.cli.containers(**{'all':     True,
                                            'trunc':   False,
                                            'filters': {'name': name}})

        if not containers:
            LOG.warning("Container %r not found", name)
            return

        for c in containers:
            if '/%s' % name in c['Names']:
                return c

    @staticmethod
    def _calc_cpu_percent(cur_stats, pre_stats):
        r = 0.0

        if not cur_stats.get('system_cpu_usage'):
            return r

        if not pre_stats or not pre_stats.get('system_cpu_usage'):
            return r

        if pre_stats:
            cpu_delta = float(cur_stats['cpu_usage']['total_usage']) - float(pre_stats['cpu_usage']['total_usage'])
            sys_delta = float(cur_stats['system_cpu_usage']) - float(pre_stats['system_cpu_usage'])
        else:
            cpu_delta = 0.0
            sys_delta = 0.0

        if cur_stats.get('online_cpus'):
            online_cpus = cur_stats['online_cpus']
        else:
            online_cpus = len(cur_stats['cpu_usage']['percpu_usage'])

        if cpu_delta > 0.0 and sys_delta > 0.0:
            r = (cpu_delta / sys_delta) * online_cpus * 100.0

        return round(r, 2)

    def _calc_mem_usage(self, data):
        usage = data.get('usage', 0)

        if self.action == 'monit':
            return usage

        return bitmath.Byte(usage).best_prefix().format('{value:.2f} {unit}').replace('Bit', 'B')

    def _calc_mem_limit(self, data):
        limit = data.get('limit', 0)

        if self.action == 'monit':
            return limit

        return bitmath.Byte(limit).best_prefix().format('{value:.2f} {unit}').replace('Bit', 'B')

    @staticmethod
    def _calc_mem_percent(data):
        if not data.get('limit'):
            return 0.0

        return round(float(data['usage']) / float(data['limit']) * 100.0, 2)

    def _calc_network(self, data):
        rx = 0
        tx = 0

        if data:
            for v in data.itervalues():
                rx += v['rx_bytes']
                tx += v['tx_bytes']

        if self.action == 'monit':
            return (rx, tx)

        return (bitmath.Byte(rx).to_kB().best_prefix().format('{value:.1f} {unit}').replace('Bit', 'B'),
                bitmath.Byte(tx).to_kB().best_prefix().format('{value:.1f} {unit}').replace('Bit', 'B'))

    def _calc_blockio(self, data):
        read  = 0
        write = 0

        if data.get('io_service_bytes_recursive'):
            for x in data['io_service_bytes_recursive']:
                if x['op'] == 'Read':
                    read  += x['value']
                elif x['op'] == 'Write':
                    write += x['value']

        if self.action == 'monit':
            return (read, write)

        return (bitmath.Byte(read).to_kB().best_prefix().format('{value:.1f} {unit}').replace('Bit', 'B'),
                bitmath.Byte(write).to_kB().best_prefix().format('{value:.1f} {unit}').replace('Bit', 'B'))

    def do_create(self, name, conf):
        for x in self.cli.containers(**{'all': True, 'filters': {'name': name}}):
            if 'Names' in x and "/%s" % name in x['Names']:
                LOG.error("Container %r already exists", name)
                return

        params = self._build_create_params(conf)
        if not params:
            return

        if 'host_config' in params:
            params['host_config'] = self.cli.create_host_config(**params['host_config'])

            if 'PortBindings' in params['host_config']:
                params['ports'] = []
                for port in params['host_config']['PortBindings'].iterkeys():
                    params['ports'].append(tuple(port.split('/', 1)))

        cid_dir = os.path.dirname(os.path.realpath(conf['general']['cid_file']))
        if not os.access(cid_dir, os.F_OK):
            os.makedirs(cid_dir)

        LOG.info("[%s] Creating", name)

        container = self.cli.create_container(**params)

        if not container or not container.get('Id'):
            LOG.error("[%s] Unable to get container Id from API", name)
            return

        if container.get('Warnings'):
            LOG.warning("[%s] %r", name, container['Warnings'])

        if not self.lock_cidfile(container['Id'], conf['general']['cid_file']):
            LOG.error("[%s] Unable to write cid_file: %r",
                      name,
                      conf['general']['cid_file'])

        return container

    def do_kill(self, name, conf):
        LOG.info("[%s] Killing", name)
        self.cli.kill(name)

    def pre_do_list(self):
        if self.options.imgname:
            if self.options.imgname not in self.confs['images']:
                LOG.error("Image %r not found in configuration files", self.options.imgname)
            else:
                self.do_list(self.confs['images'][self.options.imgname])
        else:
            self.do_list(self.confs['names'])

        return StatusReturn

    @staticmethod
    def do_list(confs):
        print "Containers:"
        for name in sorted(confs.iterkeys()):
            if confs[name]['enable']:
                enabled = "yes"
            else:
                enabled = "no"
            print "    - %s (enabled: %s)" % (name, enabled)

    def pre_do_pull(self):
        if not self.options.imgname:
            return StatusContinue
        elif self.options.dockerurl or self.options.force:
            self.do_pull(None, self.default_conf)
            return StatusReturn

        return StatusContinue

    def do_pull(self, name, conf):
        docker_url = conf['docker_url']

        if self.options.imgname:
            image = self.options.imgname
        else:
            image = conf['general']['image']

        self.set_client(self.register_client(docker_url))

        if docker_url not in _IMAGES['pull']:
            _IMAGES['pull'][docker_url] = set()

        if image in _IMAGES['pull'][docker_url]:
            return

        for line in self.cli.pull(image, stream = True):
            data    = json.loads(line)
            if 'errorDetail' in data:
                LOG.error("[%s] %s", docker_url, data['errorDetail']['message'])
                return
            elif 'id' in data:
                LOG.info("[%s] %s: %s", docker_url, data['id'], data['status'])
            else:
                LOG.info("[%s] %s", docker_url, data['status'])

        _IMAGES['pull'][docker_url].add(image)

    def do_reload(self, name, conf):
        self.do_remove(name, conf)
        self.do_run(name, conf)

    def do_remove(self, name, conf):
        if not self.options.force:
            self.do_stop(name, conf)

        LOG.info("[%s] Removing", name)
        try:
            self.cli.remove_container(name,
                                      force = self.options.force)
        except Exception, e:
            if not self.options.force:
                raise
        self.unlock_cidfile(conf['general']['cid_file'])

    def pre_do_remove_image(self):
        if not self.options.imgname:
            return StatusContinue
        elif self.options.dockerurl or self.options.force:
            self.do_remove_image(None, self.default_conf)
            return StatusReturn

        return StatusContinue

    def do_remove_image(self, name, conf):
        docker_url = conf['docker_url']

        if self.options.imgname:
            image = self.options.imgname
        else:
            image = conf['general']['image']

        self.set_client(self.register_client(docker_url))

        if docker_url not in _IMAGES['remove']:
            _IMAGES['remove'][docker_url] = set()

        if image in _IMAGES['remove'][docker_url]:
            return

        self.cli.remove_image(image, force = self.options.force)
        _IMAGES['remove'][docker_url].add(image)

    def do_restart(self, name, conf):
        self.do_stop(name, conf)
        self.do_start(name, conf)

    def do_run(self, name, conf):
        self.do_create(name, conf)
        self.do_start(name, conf)

    def do_start(self, name, conf):
        LOG.info("[%s] Starting", name)
        self.cli.start(name)

    def do_state(self, name, conf):
        container = self._find_container(name, conf)

        if not container:
            return

        state = self._get_state(container['Id'])
        if not state:
            LOG.warning("Unable to fetch container information: %r", name)
            return

        if self.options.name and not self.scale:
            print state
        else:
            print "%s: %s" % (name, state)

    def _get_resource_info(self, choice, current, previous):
        if choice == 'mem_usage':
            return self._calc_mem_usage(current['memory_stats'])
        elif choice == 'mem_limit':
            return self._calc_mem_limit(current['memory_stats'])
        elif choice == 'mem_percent':
            return self._calc_mem_percent(current['memory_stats'])
        elif choice == 'cpu_percent':
            return self._calc_cpu_percent(current['cpu_stats'],
                                          previous.get('cpu_stats'))
        elif choice == 'io_read':
            return self._calc_blockio(current.get('blkio_stats'))[0]
        elif choice == 'io_write':
            return self._calc_blockio(current.get('blkio_stats'))[1]
        elif choice == 'net_tx':
            return self._calc_blockio(current.get('networks'))[0]
        elif choice == 'net_rx':
            return self._calc_blockio(current.get('networks'))[1]

    def do_stats(self, name, conf):
        container = self._find_container(name, conf)

        if not container:
            return

        for line in self.cli.stats(container['Id'], stream = True):
            data  = json.loads(line)

            if not conf['_stats']:
                conf['_stats'] = data
                continue
            elif data['read'] == conf['_stats']['read']:
                continue

            if self.action == 'monit':
                rsc = self.options.resource[0]
                ret = self._get_resource_info(rsc, data, conf['_stats'])

                if rsc.endswith('_percent'):
                    ret = int(ret)
                else:
                    ret = str(ret)

                StatusReturnCode.RETURN_CODE = ret

                return StatusReturnCode

            r = ["%s" % name]

            for choice in self.options.resource:
                r.append("%s:%s" % (choice, self._get_resource_info(choice, data, conf['_stats'])))

            print '|'.join(r)

            return

    def do_monit(self, name, conf):
        return self.do_stats(name, conf)

    def do_status(self, name, conf):
        container = self._find_container(name, conf)

        if not container:
            return

        print "Container: %r" % name
        for key in STATUS_KEYS:
            key_view = "%s:" % key
            if key == 'Created':
                print "    %-10s%s" % (key_view,
                                       time.strftime('%Y-%m-%d %H:%M:%S',
                                                     time.localtime(container['Created'])))
            elif key == 'Ports':
                ports = []
                for port in container['Ports']:
                    binding = ""
                    if port.get('IP'):
                        binding += port['IP']
                    if port.get('PublicPort'):
                        binding += ":%s" % port['PublicPort']
                    binding = binding.lstrip(':')
                    if binding:
                        binding = "%s->" % binding

                    ports.append("%s%s/%s" % (binding,
                                              port['PrivatePort'],
                                              port['Type']))
                print "    %-10s%s" % (key_view, ", ".join(ports))
            elif key == 'Names':
                print "    %-10s%s" % (key_view,
                                       ", ".join([x.lstrip('/') for x in container['Names']]))
            else:
                print "    %-10s%s" % (key_view, container[key])

    def do_stop(self, name, conf):
        LOG.info("[%s] Stopping", name)
        self.cli.stop(name)

    @staticmethod
    def pre_do_top():
        stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        stdscr.keypad(1)
        stdscr.nodelay(1)
        try:
            curses.start_color()
            curses.use_default_colors()
        except:
            pass

        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(3, curses.COLOR_BLUE, curses.COLOR_WHITE)
        stdscr.clear()

        stdscr.addstr(0,
                      0,
                      CURSES_TOP_LINE_FORMAT.format(*CURSES_TOP_COLUMNS),
                      curses.color_pair(1))

        return stdscr

    def do_top(self, name, conf, i = 0, stdscr = None):
        container = self._find_container(name, conf)
        color = i % 2 + 2

        if not container:
            return

        for line in self.cli.stats(container['Id'], stream = True):
            data  = json.loads(line)

            if conf['_stats'] and data['read'] == conf['_stats']['read']:
                continue

            state = self._get_state(container['Id']) or ''

            stdscr.clrtoeol()
            stdscr.addstr(
                i,
                0,
                (CURSES_TOP_LINE_FORMAT).format(
                    name[0:50],
                    "%s" % state,
                    "%s%%" % self._calc_cpu_percent(data['cpu_stats'],
                                                    conf['_stats'].get('cpu_stats')),
                    "%s / %s" % (self._calc_mem_usage(data['memory_stats']),
                                 self._calc_mem_limit(data['memory_stats'])),
                    "%s%%" % self._calc_mem_percent(data['memory_stats']),
                    "%s / %s" % self._calc_network(data.get('networks')),
                    "%s / %s" % self._calc_blockio(data.get('blkio_stats'))),
                curses.color_pair(color))
            conf['_stats'] = data
            stdscr.refresh()
            time.sleep(0.5)

    def post_do_top(self, *args):
        while True:
            event = args[0].getch()
            if event == ord('q') or self.is_killed():
                break
            time.sleep(0.5)

    @staticmethod
    def finally_do_top(*args):
        args[0].keypad(0)
        args[0].clear()
        curses.echo()
        curses.nocbreak()
        curses.endwin()


def main(options):
    """
    Main function; start the server
    """
    logging.basicConfig(level=logging.DEBUG)
    filehandler = WatchedFileHandler(options.logfile)
    filehandler.setFormatter(logging.Formatter("%%(asctime)-15s %s[%%(process)d]: %%(message)s" % SYSLOG_NAME,
                                               datefmt='%Y-%m-%d %H:%M:%S'))
    root_logger = logging.getLogger('')
    root_logger.addHandler(filehandler)

    logging.getLogger('requests').setLevel(logging.WARNING)

    with open(options.conffile, 'r') as f:
        default_conf = yaml.load(f)

    rc           = 0
    pre_result   = None
    post_args    = []
    finally_args = []

    try:
        root_logger.setLevel(options.loglevel)
        options.action  = options.action.replace('-', '_')
        dockerator      = Dockerator(options, default_conf)

        if not dockerator.confs:
            LOG.error("No container configuration found")
            return

        if hasattr(dockerator, "pre_do_%s" % dockerator.action):
            pre_result = getattr(dockerator, "pre_do_%s" % dockerator.action)()
            if pre_result is StatusReturn:
                return

        post_args.append(pre_result)
        finally_args.append(pre_result)

        conf = dockerator.get_current_conf()
        if not conf:
            return

        i  = 1
        nb = len(conf)

        for name in sorted(conf.iterkeys()):
            if not conf[name]['enable'] \
               and conf[name]['action'] not in ('kill', 'list', 'remove', 'stop'):
                LOG.debug("Container %r is not enabled", name)
                continue

            try:
                dockerator.set_client(dockerator.register_client(conf[name]['docker_url']))
                rc   = None
                func = getattr(dockerator, "do_%s" % conf[name]['action'])
                if conf[name]['action'] not in ('top',):
                    rc = func(name, conf[name])
                else:
                    thread = threading.Thread(target = func,
                                              args = (name, conf[name], i, pre_result))
                    thread.daemon = True
                    thread.start()

                if rc is StatusReturnCode:
                    rc = StatusReturnCode.RETURN_CODE
                    break

                i += 1
            except Exception, e:
                if nb == 1:
                    raise
                LOG.error("%r", getattr(e, 'explanation', e))

        if hasattr(dockerator, "post_do_%s" % dockerator.action):
            getattr(dockerator, "post_do_%s" % dockerator.action)(*post_args)
    except APIError, e:
        rc = 180
        LOG.error("%r", e.explanation)
    except DockerException, e:
        rc = 170
        LOG.error("%r", e)
    except DockeratorConfigException, e:
        rc = 160
        LOG.error("%r", e)
    except (KeyboardInterrupt, SystemExit):
        rc = 151
        raise
    except Exception: # pylint: disable=W0703
        rc = 150
        LOG.exception("bad things happen")
    finally:
        if dockerator and hasattr(dockerator, "finally_do_%s" % dockerator.action):
            getattr(dockerator, "finally_do_%s" % dockerator.action)(*finally_args)

        for cli in _CLIENTS.itervalues():
            if cli:
                cli.close()
        sys.exit(rc)

if __name__ == '__main__':
    main(argv_parse_check())
